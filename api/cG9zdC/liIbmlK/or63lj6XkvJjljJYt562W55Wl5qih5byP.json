{"title":"分支语句优化--策略模式","date":"2019-01-25T05:00:00.000Z","author":"Mikey","excerpt":"","slug":"分支语句优化-策略模式","comments":true,"tags":["JavaScript","设计模式"],"categories":["技术博客"],"updated":"2019-01-28T06:23:14.152Z","content":"<p>在很多业务场景中，完成一项任务时，往往可以有多种不同的方式，比如我们很多商品有不同的促销方式，比如满百减10，满200返40，满三减一等等，每一种方式我们称其为一种<strong>策略</strong>。每种策略事实上都是一种针对处理相同业务的不同算法，每种算法都是相互独立的，是可以相互替代的，所以策略模式就是：</p>\n<blockquote>\n<p>定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的调用者而变化。策略模式是一种对象行为型模式。</p>\n</blockquote>\n<h2 id=\"进一步了解\"><a href=\"#进一步了解\" class=\"headerlink\" title=\"进一步了解\"></a>进一步了解</h2><p>在项目开发中，有很多需求都是使用不同的算法来实现同一种需求，比如查找、排序、表单校验等。这里我以前端更为常见的表单校验来举例。我们常用的方法是硬编码在一个公共类中，如有多种校验行为，可以将对应的校验算法写到工具类中，每一种算法对外提供一个方法以供调用。下面是在我们火车票、酒店H5项目中有关校验的写法，我们将校验方法与其他工具方法放在了工具类中同一级。</p>\n<p><img src=\"https://lh3.googleusercontent.com/MY6InMW2ow_nOZsDRQRSNd8YuCWkvSOag1CEFrI9ywn5bF-ZHD_At-Hn0iLX71i4LeERs4KHjvw\" alt=\"enter image description here\"></p>\n<p>当然也可以将这些校验算法封装在一个统一的方法中，通过if…else…等条件判断语句来进行选择。这两种实现方法我们都可以称之为<strong>硬编码</strong>，如果需要增加一种新的校验方式，需要修改封装算法工具类的源代码；更换查找算法，也需要修改调用端的代码。</p>\n<p>其实我们在利用某些动画库写动效时，一定会见到类似如下的写法：</p>\n<pre><code>animate({width: &apos;200px&apos;}, 1000, &apos;linear&apos;)\n</code></pre><p>其中，第三个参数可选不同的缓动算法，比如linear、easeout等，算法复杂的处理过程对调用者隐藏，这是一个很典型的策略模式应用。</p>\n<h2 id=\"模式实例\"><a href=\"#模式实例\" class=\"headerlink\" title=\"模式实例\"></a>模式实例</h2><p>我们希望表单校验的调用也可以如此优雅，下面是一个表单正则校验策略对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 表单正则验证策略对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Inputstrategy = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> strategy = &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 是否为空</span></span><br><span class=\"line\">\t\tnotNull: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"regexp\">/\\s+/</span>.test(value) ? <span class=\"string\">'请输入内容'</span> : <span class=\"string\">''</span></span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t<span class=\"comment\">// 是否是个数字</span></span><br><span class=\"line\">\t\tnumber: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"regexp\">/^[0-9]+(\\.[0-9]+)?$/</span>.test(value) ? <span class=\"string\">''</span> : <span class=\"string\">'请输入数字'</span></span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t<span class=\"comment\">// 是否是本地电话</span></span><br><span class=\"line\">\t\tphone: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"regexp\">/^\\d&#123;3&#125;\\-\\d&#123;8&#125;$|^\\d&#123;4&#125;\\-\\d&#123;7&#125;$/</span>.test(value) ? <span class=\"string\">''</span> : <span class=\"string\">'请输入正确的电话号'</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 验证接口type算法value表单值</span></span><br><span class=\"line\">\t\tcheck: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">type, value</span>) </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 去除首尾空白符</span></span><br><span class=\"line\">\t\t\tvalue = value.replace(<span class=\"regexp\">/^\\s+|\\s+$/g</span>, <span class=\"string\">''</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> strategy[type] ? strategy[type](value) : <span class=\"string\">'没有该类型的检测方法'</span></span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t<span class=\"comment\">// 添加策略</span></span><br><span class=\"line\">\t\taddStrategy: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">type, fn</span>) </span>&#123;</span><br><span class=\"line\">\t\t\tstrategy[type] = fn</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;()</span><br></pre></td></tr></table></figure>\n<p>可以看到这个策略类除了导出一个check方法做校验，还导出了一个添加策略的方法addStrategy，这样即可实现策略方法的临时性修改，而不需要修改策略对象内部的代码。</p>\n<pre><code>Inputstrategy.ckeck(&apos;nickname&apos;, &apos;xxxxxxxx&apos;)\n</code></pre><p>如此的调用方式更加清晰可读，算法实现类中也不再臃肿无序。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>策略模式<strong>主要优点在于对“开闭原则”的完美支持</strong>，在不修改原有系统的基础上可以更换算法或者增加新的算法，它很好地管理算法族，提高了代码的复用性，是一种替换继承，避免多重条件转移语句的实现方式；其缺点在于客户端必须知道所有的策略类，并理解其区别，增加了用户对策略类使用的成本，同时在一定程度上增加了系统中类的个数，可能会存在很多策略类。</p>\n<p>对于分支语句优化，一共有三种模式涉及。分别为工厂方法模式、状态模式和策略模式。对于工厂方法模式，它是一种创建型模式，他的<strong>最终目的是创建对象</strong>。而状态模式和策略模式都是行为型模式，在状态模式中，其核心是<strong>对状态的控制来决定不同的行为表现</strong>，所以状态之间通常是不可替代的，否则将产生不同的行为结果。而<strong>策略模式核心是算法</strong>，往往每种算法要处理的业务逻辑相同，因此他们可以相互替换，当然策略类也不必关心调用者的环境，因为同一种策略模式最终产出的结果是一定的。</p>\n<p><em>参考文献</em></p>\n<ul>\n<li><a href=\"https://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/strategy.html\" target=\"_blank\" rel=\"noopener\">图说设计模式</a></li>\n<li>JavaScript设计模式  张容铭</li>\n</ul>\n","prev":{"title":"分支语句优化--状态模式","slug":"分支语句优化-状态模式"},"next":{"title":"CSS 3D变换手册","slug":"CSS_3D变换手册"},"link":"http://mickeywang.com/post/分支语句优化-策略模式"}